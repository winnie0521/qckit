{
    "collab_server" : "",
    "contents" : "//\n// Created by aragaven on 8/31/17.\n//\n\n// ============================================================================\n// gzstream, C++ iostream classes wrapping the zlib compression library.\n// Copyright (C) 2001  Deepak Bandyopadhyay, Lutz Kettner\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n// ============================================================================\n//\n// File          : gzstream.C\n// Revision      : $Revision: 1.7 $\n// Revision_date : $Date: 2003/01/08 14:41:27 $\n// Author(s)     : Deepak Bandyopadhyay, Lutz Kettner\n//\n// Standard streambuf implementation following Nicolai Josuttis, \"The\n// Standard C++ Library\".\n// ============================================================================\n\n#include \"gzstream.h\"\n#include <iostream>\n#include <string.h>  // for memcpy\n\n#ifdef GZSTREAM_NAMESPACE\nnamespace GZSTREAM_NAMESPACE {\n#endif\n\n// ----------------------------------------------------------------------------\n// Internal classes to implement gzstream. See header file for user classes.\n// ----------------------------------------------------------------------------\n\n// --------------------------------------\n// class gzstreambuf:\n// --------------------------------------\n\ngzstreambuf* gzstreambuf::open( const char* name, int open_mode) {\n  if ( is_open())\n    return (gzstreambuf*)0;\n  mode = open_mode;\n  // no append nor read/write mode\n  if ((mode & std::ios::ate) || (mode & std::ios::app)\n        || ((mode & std::ios::in) && (mode & std::ios::out)))\n    return (gzstreambuf*)0;\n  char  fmode[10];\n  char* fmodeptr = fmode;\n  if ( mode & std::ios::in)\n    *fmodeptr++ = 'r';\n  else if ( mode & std::ios::out)\n    *fmodeptr++ = 'w';\n  *fmodeptr++ = 'b';\n  *fmodeptr = '\\0';\n  file = gzopen( name, fmode);\n  if (file == 0)\n    return (gzstreambuf*)0;\n  opened = 1;\n  return this;\n}\n\ngzstreambuf * gzstreambuf::close() {\n  if ( is_open()) {\n    sync();\n    opened = 0;\n    if ( gzclose( file) == Z_OK)\n      return this;\n  }\n  return (gzstreambuf*)0;\n}\n\nint gzstreambuf::underflow() { // used for input buffer only\n  if ( gptr() && ( gptr() < egptr()))\n    return * reinterpret_cast<unsigned char *>( gptr());\n\n  if ( ! (mode & std::ios::in) || ! opened)\n    return EOF;\n  // Josuttis' implementation of inbuf\n  int n_putback = gptr() - eback();\n  if ( n_putback > 4)\n    n_putback = 4;\n  memcpy( buffer + (4 - n_putback), gptr() - n_putback, n_putback);\n\n  int num = gzread( file, buffer+4, bufferSize-4);\n  if (num <= 0) // ERROR or EOF\n    return EOF;\n\n  // reset buffer pointers\n  setg( buffer + (4 - n_putback),   // beginning of putback area\n        buffer + 4,                 // read position\n        buffer + 4 + num);          // end of buffer\n\n  // return next character\n  return * reinterpret_cast<unsigned char *>( gptr());\n}\n\nint gzstreambuf::flush_buffer() {\n  // Separate the writing of the buffer from overflow() and\n  // sync() operation.\n  int w = pptr() - pbase();\n  if ( gzwrite( file, pbase(), w) != w)\n    return EOF;\n  pbump( -w);\n  return w;\n}\n\nint gzstreambuf::overflow( int c) { // used for output buffer only\n  if ( ! ( mode & std::ios::out) || ! opened)\n    return EOF;\n  if (c != EOF) {\n    *pptr() = c;\n    pbump(1);\n  }\n  if ( flush_buffer() == EOF)\n    return EOF;\n  return c;\n}\n\nint gzstreambuf::sync() {\n  // Changed to use flush_buffer() instead of overflow( EOF)\n  // which caused improper behavior with std::endl and flush(),\n  // bug reported by Vincent Ricard.\n  if ( pptr() && pptr() > pbase()) {\n    if ( flush_buffer() == EOF)\n      return -1;\n  }\n  return 0;\n}\n\n// --------------------------------------\n// class gzstreambase:\n// --------------------------------------\n\ngzstreambase::gzstreambase( const char* name, int mode) {\n  init( &buf);\n  open( name, mode);\n}\n\ngzstreambase::~gzstreambase() {\n  buf.close();\n}\n\nvoid gzstreambase::open( const char* name, int open_mode) {\n  if ( ! buf.open( name, open_mode))\n    clear( rdstate() | std::ios::badbit);\n}\n\nvoid gzstreambase::close() {\n  if ( buf.is_open())\n    if ( ! buf.close())\n      clear( rdstate() | std::ios::badbit);\n}\n\n#ifdef GZSTREAM_NAMESPACE\n} // namespace GZSTREAM_NAMESPACE\n#endif\n\n// ============================================================================\n// EOF //\n",
    "created" : 1522785676264.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1577831782",
    "id" : "2E1C823D",
    "lastKnownWriteTime" : 1520953770,
    "last_content_update" : 1520953770,
    "path" : "~/Documents/Rdata/qckitW/src/gzstream.cpp",
    "project_path" : "src/gzstream.cpp",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "cpp"
}