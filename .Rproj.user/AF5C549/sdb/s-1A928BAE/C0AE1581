{
    "collab_server" : "",
    "contents" : "#include <Rcpp.h>\n#include <iostream>\n#include <map>\n#include <fstream>\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <cstdint>\n#include \"gzstream.h\"\n#include \"zlib.h\"\n\nusing namespace Rcpp;\n\n//' calculate Over Rep seqs\n//'\n//'\n//' @param infile  A string giving the path for the fastqfile\n//' @param out_prefix A string giving the prefix to be used for outputs\n//' @param buffer_size An int for the number of lines to keep in memory\n//' @export\n// [[Rcpp::plugins(cpp11)]]\n// [[Rcpp::export]]\n void process_fastq (std::string infile, std::string out_prefix, int buffer_size)\n  {\n  std::map<char, int> ascii_map;\n  ascii_map['!'] = 0;\n  ascii_map['\"'] = 1;\n  ascii_map['#'] = 2;\n  ascii_map['$'] = 3;\n  ascii_map['%'] = 4;\n  ascii_map['&'] = 5;\n  ascii_map['\\''] = 6;\n  ascii_map['('] = 7;\n  ascii_map[')'] = 8;\n  ascii_map['*'] = 9;\n  ascii_map['+'] = 10;\n  ascii_map[','] = 11;\n  ascii_map['-'] = 12;\n  ascii_map['.'] = 13;\n  ascii_map['/'] = 14;\n  ascii_map['0'] = 15;\n  ascii_map['1'] = 16;\n  ascii_map['2'] = 17;\n  ascii_map['3'] = 18;\n  ascii_map['4'] = 19;\n  ascii_map['5'] = 20;\n  ascii_map['6'] = 21;\n  ascii_map['7'] = 22;\n  ascii_map['8'] = 23;\n  ascii_map['9'] = 24;\n  ascii_map[':'] = 25;\n  ascii_map[';'] = 26;\n  ascii_map['<'] = 27;\n  ascii_map['='] = 28;\n  ascii_map['>'] = 29;\n  ascii_map['?'] = 30;\n  ascii_map['@'] = 31;\n  ascii_map['A'] = 32;\n  ascii_map['B'] = 33;\n  ascii_map['C'] = 34;\n  ascii_map['D'] = 35;\n  ascii_map['E'] = 36;\n  ascii_map['F'] = 37;\n  ascii_map['G'] = 38;\n  ascii_map['H'] = 39;\n  ascii_map['I'] = 40;\n  ascii_map['J'] = 41;\n  ascii_map['K'] = 42;\n  ascii_map['L'] = 43;\n  ascii_map['M'] = 44;\n  ascii_map['N'] = 45;\n  ascii_map['O'] = 46;\n  ascii_map['P'] = 47;\n  ascii_map['Q'] = 48;\n  ascii_map['R'] = 49;\n  ascii_map['S'] = 50;\n  ascii_map['T'] = 51;\n  ascii_map['U'] = 52;\n  ascii_map['V'] = 53;\n  ascii_map['W'] = 54;\n  ascii_map['X'] = 55;\n  ascii_map['Y'] = 56;\n  ascii_map['Z'] = 57;\n  ascii_map['['] = 58;\n  ascii_map['\\\\'] = 59;\n  ascii_map[']'] = 60;\n  ascii_map['^'] = 61;\n  ascii_map['_'] = 62;\n  ascii_map['`'] = 63;\n  ascii_map['a'] = 64;\n  ascii_map['b'] = 65;\n  ascii_map['c'] = 66;\n  ascii_map['d'] = 67;\n  ascii_map['e'] = 68;\n  ascii_map['f'] = 69;\n  ascii_map['g'] = 70;\n  ascii_map['h'] = 71;\n  ascii_map['i'] = 72;\n  ascii_map['j'] = 73;\n  ascii_map['k'] = 74;\n  ascii_map['l'] = 75;\n  ascii_map['m'] = 76;\n  ascii_map['n'] = 77;\n  ascii_map['o'] = 78;\n  ascii_map['p'] = 79;\n  ascii_map['q'] = 80;\n  ascii_map['r'] = 81;\n  ascii_map['s'] = 82;\n  ascii_map['t'] = 83;\n  ascii_map['u'] = 84;\n  ascii_map['v'] = 85;\n  ascii_map['w'] = 86;\n  ascii_map['x'] = 87;\n  ascii_map['y'] = 88;\n  ascii_map['z'] = 89;\n  ascii_map['{'] = 90;\n  ascii_map['|'] = 91;\n  ascii_map['}'] = 92;\n  ascii_map['~'] = 93;\n\n  std::map<std::string, int> over_rep_map;\n  std::map<std::string,int>::iterator it;\n  std::map<int,std::vector<int> > qual_by_column;\n  std::map<int,std::vector<int> >::iterator qual_by_col_it;\n\n  //std::string seq_out = out_prefix + \".seq.csv\";\n  //std::string qual_char_out = out_prefix + \".qual.char.csv\";\n  //std::string qual_num_out = out_prefix + \".qual.num.csv\";\n  //std::ofstream seq_file, qual_char_file, qual_num_file;\n\n  std::string over_rep_out = out_prefix + \".over_rep.csv\";\n  std::ofstream over_rep_file;\n\n  /*seq_file.open(seq_out.c_str());\n  qual_char_file.open(qual_char_out.c_str());\n  qual_num_file.open(qual_num_out.c_str());*/\n  over_rep_file.open(over_rep_out.c_str());\n\n  gz::igzstream in(infile.c_str());\n  std::string line;\n  int count = 1, line_count =1;\n  //std::vector<int,std::vector<int> > base_counts;\n  std::vector<double> gc_percent_all;\n  while (std::getline(in, line)) {\n\n    if (count == 2)\n      {\n        it = over_rep_map.find(line);\n        if (it != over_rep_map.end())\n        {\n          // if found increment by 1\n          over_rep_map.at(line) += 1;\n        }\n        else\n        {\n          // if not found add new key and initialize to 1\n          over_rep_map.insert(std::pair<std::string, int>(line,1));\n        }\n        // iterating over each character in the string\n        std::string base_cmp;\n        //std::vector<int> counts_per_read;\n        int count_A=0, count_G=0, count_T=0, count_C=0, count_N=0;\n        for (std::string::iterator it = line.begin(); it != line.end(); ++it)\n          {\n            base_cmp.clear();\n            base_cmp.push_back(*it);\n            if (base_cmp.compare(\"A\") ==0) { count_A +=1;}\n            else if (base_cmp.compare(\"T\")==0) { count_T +=1;}\n            else if (base_cmp.compare(\"G\")==0) { count_G +=1;}\n            else if (base_cmp.compare(\"C\")==0) { count_C +=1;}\n            else if (base_cmp.compare(\"N\")==0) { count_N +=1;}\n          }\n        double gc_percent = static_cast<double>(count_C+count_G)/static_cast<double>(count_A+count_T+count_G+count_C+count_N);\n        gc_percent_all.push_back(gc_percent);\n        /*counts_per_read.push_back(count_A);\n        counts_per_read.push_back(count_T);\n        counts_per_read.push_back(count_G);\n        counts_per_read.push_back(count_C);\n        counts_per_read.push_back(count_N);\n        base_counts.insert(line_count,counts_per_read);*/\n\n      }\n\n    if (count == 4)\n      {\n       // iterate over each value for quality\n       int pos_counter = 1;\n        for (std::string::iterator it = line.begin(); it != line.end(); ++it)\n          {\n           qual_by_col_it = qual_by_column.find(pos_counter);\n            if(qual_by_col_it != qual_by_column.end())\n            {\n              qual_by_column.at(pos_counter).push_back(ascii_map.find(*it)->second);\n            }\n            else\n            {\n              std::vector<int> tmp;\n              tmp.push_back(ascii_map.find(*it)->second);\n              qual_by_column.insert(std::pair<int, std::vector<int> >(pos_counter,tmp));\n            }\n          }\n      count = 1;\n      }\n    else\n      {\n      count++;\n      }\n  }\n  //Cleanup\n  in.close();\n\n  /*TODO\n    write over_rep sequences to file\n    return gc_percent vector\n    return per column mean, median and quantile\n   */\n  over_rep_file.close();\n\n  return ;\n}\n\n\n//' calculate summary of quality scores over position\n//'\n//' Description\n//' @param inmat A matrix of score vectors per position\n// [[Rcpp::plugins(cpp11)]]\n\nstd::vector<std::vector<int> > qual_score_per_position (const std::map<int,std::vector<uint8_t> > &inmat)\n{\n  std::vector<std::vector<int> > qual_score_mat_results;\n  std::vector<int> q_01,q_25, q_50,q_75, q_99;\n\n  std::map<int,std::vector<uint8_t> >::const_iterator mat_it = inmat.begin();\n\n  for(mat_it = inmat.begin(); mat_it !=inmat.end(); mat_it++)\n  {\n    std::vector<uint8_t> quantile = mat_it->second;\n\n    int Q1 = static_cast<int> (quantile.size()*0.01);\n    int Q25 = (quantile.size()+1) / 4;\n    int Q50= (quantile.size()+1) / 2;\n    int Q75 = Q25 + Q50;\n    int Q99 = static_cast<int> (quantile.size()*0.99) ;\n\n    std::nth_element(quantile.begin(),quantile.begin() + Q1, quantile.end());\n    q_01.push_back(static_cast<int>(quantile[Q1]));\n    quantile.clear();\n\n    std::nth_element(quantile.begin(),quantile.begin() + Q25, quantile.end());\n    q_25.push_back(static_cast<int>(quantile[Q25]));\n    quantile.clear();\n\n    quantile = mat_it->second;\n    std::nth_element(quantile.begin(), quantile.begin() + Q50, quantile.end());\n    q_50.push_back(static_cast<int>(quantile[Q50]));\n    quantile.clear();\n\n    quantile = mat_it->second;\n    std::nth_element(quantile.begin(), quantile.begin() + Q75, quantile.end());\n    q_75.push_back(static_cast<int>(quantile[Q75]));\n\n    std::nth_element(quantile.begin(),quantile.begin() + Q99, quantile.end());\n    q_99.push_back(static_cast<int>(quantile[Q99]));\n    quantile.clear();\n  }\n  qual_score_mat_results.push_back(q_01);\n  qual_score_mat_results.push_back(q_25);\n  qual_score_mat_results.push_back(q_50);\n  qual_score_mat_results.push_back(q_75);\n  qual_score_mat_results.push_back(q_99);\n  return qual_score_mat_results ;\n}\n\n//' calculate mean quality per read\n//'\n//' Calculate the mean quality score per read of the FASTQ gzipped file\n//' @param infile A string giving the path for the fastqfile\n//' @export\n// [[Rcpp::plugins(cpp11)]]\n// [[Rcpp::export]]\nRcpp::List qual_score_per_read (std::string infile)\n{\n  std::map<char, uint8_t> ascii_map;\n  ascii_map['!'] = 0;\n  ascii_map['\"'] = 1;\n  ascii_map['#'] = 2;\n  ascii_map['$'] = 3;\n  ascii_map['%'] = 4;\n  ascii_map['&'] = 5;\n  ascii_map['\\''] = 6;\n  ascii_map['('] = 7;\n  ascii_map[')'] = 8;\n  ascii_map['*'] = 9;\n  ascii_map['+'] = 10;\n  ascii_map[','] = 11;\n  ascii_map['-'] = 12;\n  ascii_map['.'] = 13;\n  ascii_map['/'] = 14;\n  ascii_map['0'] = 15;\n  ascii_map['1'] = 16;\n  ascii_map['2'] = 17;\n  ascii_map['3'] = 18;\n  ascii_map['4'] = 19;\n  ascii_map['5'] = 20;\n  ascii_map['6'] = 21;\n  ascii_map['7'] = 22;\n  ascii_map['8'] = 23;\n  ascii_map['9'] = 24;\n  ascii_map[':'] = 25;\n  ascii_map[';'] = 26;\n  ascii_map['<'] = 27;\n  ascii_map['='] = 28;\n  ascii_map['>'] = 29;\n  ascii_map['?'] = 30;\n  ascii_map['@'] = 31;\n  ascii_map['A'] = 32;\n  ascii_map['B'] = 33;\n  ascii_map['C'] = 34;\n  ascii_map['D'] = 35;\n  ascii_map['E'] = 36;\n  ascii_map['F'] = 37;\n  ascii_map['G'] = 38;\n  ascii_map['H'] = 39;\n  ascii_map['I'] = 40;\n  ascii_map['J'] = 41;\n  ascii_map['K'] = 42;\n  ascii_map['L'] = 43;\n  ascii_map['M'] = 44;\n  ascii_map['N'] = 45;\n  ascii_map['O'] = 46;\n  ascii_map['P'] = 47;\n  ascii_map['Q'] = 48;\n  ascii_map['R'] = 49;\n  ascii_map['S'] = 50;\n  ascii_map['T'] = 51;\n  ascii_map['U'] = 52;\n  ascii_map['V'] = 53;\n  ascii_map['W'] = 54;\n  ascii_map['X'] = 55;\n  ascii_map['Y'] = 56;\n  ascii_map['Z'] = 57;\n  ascii_map['['] = 58;\n  ascii_map['\\\\'] = 59;\n  ascii_map[']'] = 60;\n  ascii_map['^'] = 61;\n  ascii_map['_'] = 62;\n  ascii_map['`'] = 63;\n  ascii_map['a'] = 64;\n  ascii_map['b'] = 65;\n  ascii_map['c'] = 66;\n  ascii_map['d'] = 67;\n  ascii_map['e'] = 68;\n  ascii_map['f'] = 69;\n  ascii_map['g'] = 70;\n  ascii_map['h'] = 71;\n  ascii_map['i'] = 72;\n  ascii_map['j'] = 73;\n  ascii_map['k'] = 74;\n  ascii_map['l'] = 75;\n  ascii_map['m'] = 76;\n  ascii_map['n'] = 77;\n  ascii_map['o'] = 78;\n  ascii_map['p'] = 79;\n  ascii_map['q'] = 80;\n  ascii_map['r'] = 81;\n  ascii_map['s'] = 82;\n  ascii_map['t'] = 83;\n  ascii_map['u'] = 84;\n  ascii_map['v'] = 85;\n  ascii_map['w'] = 86;\n  ascii_map['x'] = 87;\n  ascii_map['y'] = 88;\n  ascii_map['z'] = 89;\n  ascii_map['{'] = 90;\n  ascii_map['|'] = 91;\n  ascii_map['}'] = 92;\n  ascii_map['~'] = 93;\n\n  std::vector<double> quality_score_per_read;\n  std::vector<uint8_t> qual_by_column;\n  std::vector<uint8_t>::iterator qual_by_col_it;\n\n  std::map<int,std::vector<uint8_t> > qual_score_matrix;\n\n  gz::igzstream in(infile.c_str());\n  std::string line;\n  int count = 1;\n  double quality_score_mean = 0;\n  while (std::getline(in, line))\n    {\n\n    if (count == 4)\n    {\n      // iterate over each value for quality\n      qual_by_column.clear();\n      int pos_counter = 1;\n      for (std::string::iterator it = line.begin(); it != line.end(); ++it)\n      {\n          qual_by_column.push_back(ascii_map.find(*it)->second);\n          if(pos_counter <= qual_score_matrix.size())\n          {\n          qual_score_matrix[pos_counter].push_back(ascii_map.find(*it)->second);\n          }\n          else\n          {\n            qual_score_matrix.insert(std::pair<int,uint8_t>(pos_counter,ascii_map.find(*it)->second ));\n          }\n          pos_counter++;\n      }\n      quality_score_mean = static_cast<double>(std::accumulate(qual_by_column.begin(), qual_by_column.end(),\n                                           0.0))/static_cast<double>(qual_by_column.size());\n      quality_score_per_read.push_back(quality_score_mean);\n      count = 1;\n    }\n    else\n    {\n      count++;\n    }\n  }\n  std::vector<std::vector<int> > qual_score_summary_by_position;\n  qual_score_summary_by_position = qual_score_per_position(qual_score_matrix);\n\n  std::vector<double> mu_per_position;\n  std::map<int,std::vector<uint8_t> >::iterator mat_it = qual_score_matrix.begin();\n\n  for(mat_it = qual_score_matrix.begin(); mat_it != qual_score_matrix.end(); mat_it++)\n  {\n    std::vector<uint8_t> quantile = mat_it->second;\n\n    mu_per_position.push_back(static_cast<double>(std::accumulate(quantile.begin(),\n                                                                  quantile.end(),0.0))/static_cast<double>(quantile.size()));\n  }\n  //Cleanup\n  in.close();\n  return Rcpp::List::create(Rcpp::Named(\"mu_per_read\") = quality_score_per_read,\n                            Rcpp::Named(\"mu_per_position\") = mu_per_position,\n                            Rcpp::Named(\"q01_per_position\") = qual_score_summary_by_position[0],\n                            Rcpp::Named(\"q25_per_position\") = qual_score_summary_by_position[1],\n                            Rcpp::Named(\"q50_per_position\") = qual_score_summary_by_position[2],\n                            Rcpp::Named(\"q75_per_position\") = qual_score_summary_by_position[3],\n                            Rcpp::Named(\"q99_per_position\") = qual_score_summary_by_position[4]);\n  }\n\n\n//' calculate GC percent per read\n//'\n//' Calculate GC nucleotide sequence content per read of the FASTQ gzipped file\n//' @param infile A string giving the path for the fastqfile\n//' @export\n// [[Rcpp::plugins(cpp11)]]\n// [[Rcpp::export]]\nRcpp::NumericVector gc_per_read (std::string infile)\n{\n\n  std::map<int,std::vector<int> > qual_by_column;\n  std::map<int,std::vector<int> >::iterator qual_by_col_it;\n\n\n  gz::igzstream in(infile.c_str());\n  std::string line;\n  int count = 1, line_count =1;\n  //std::vector<int,std::vector<int> > base_counts;\n  std::vector<double> gc_percent_per_read;\n  while (std::getline(in, line))\n    {\n\n    if (count == 2)\n    {\n      // iterating over each character in the string\n      std::string base_cmp;\n      int count_A=0, count_G=0, count_T=0, count_C=0, count_N=0;\n      for (std::string::iterator it = line.begin(); it != line.end(); ++it)\n      {\n        base_cmp.clear();\n        base_cmp.push_back(*it);\n        if (base_cmp.compare(\"A\") ==0) { count_A +=1;}\n        else if (base_cmp.compare(\"T\")==0) { count_T +=1;}\n        else if (base_cmp.compare(\"G\")==0) { count_G +=1;}\n        else if (base_cmp.compare(\"C\")==0) { count_C +=1;}\n        else if (base_cmp.compare(\"N\")==0) { count_N +=1;}\n      }\n      double gc_percent = static_cast<double>(count_C+count_G)/static_cast<double>(count_A+count_T+count_G+count_C+count_N);\n      gc_percent_per_read.push_back(gc_percent);\n    }\n\n    if (count == 4)\n    {\n      // Reset counter\n      count = 1;\n    }\n    else\n    {\n      count++;\n    }\n  }\n  //Cleanup\n  in.close();\n\n  return wrap(gc_percent_per_read);\n}\n\n\n//' calculate Over Rep seqs\n//'\n//' Calculate sequece counts for each unique sequence and create a table with unique sequences and corresponding counts\n//' @param infile A string giving the path for the fastqfile\n//' @param out_prefix A string giving the prefix to be used for outputs\n//' @param min_size An int for thhresholding over representation\n//' @param buffer_size An int for the number of lines to keep in memory\n//' @export\n// [[Rcpp::plugins(cpp11)]]\n// [[Rcpp::export]]\nstd::map<std::string,int> calc_over_rep_seq (std::string infile, std::string out_prefix,\n                                             int min_size=5, int buffer_size = 1000000)\n{\n  std::map<std::string, int> over_rep_map;\n  std::map<std::string,int>::iterator it;\n  std::map<int,std::vector<int> > qual_by_column;\n  std::map<int,std::vector<int> >::iterator qual_by_col_it;\n\n  /*\n   TODO: Check to see if this needs to be written to file instead\n\n  std::string over_rep_out = out_prefix + \".over_rep.csv\";\n  std::ofstream over_rep_file;\n  over_rep_file.open(over_rep_out.c_str());*/\n\n  gz::igzstream in(infile.c_str());\n  std::string line;\n  int count = 1, line_count =1;\n  while (std::getline(in, line))\n    {\n\n    if (count == 2)\n    {\n      it = over_rep_map.find(line);\n      if (it != over_rep_map.end())\n      {\n        // if found increment by 1\n        over_rep_map.at(line) += 1;\n      }\n      else\n      {\n        // if not found add new key and initialize to 1\n        over_rep_map.insert(std::pair<std::string, int>(line,1));\n      }\n    }\n    if (count == 4)\n    {\n      // reset count\n      count = 1;\n    }\n    else\n    {\n      count++;\n      }\n    // Reduce map after 1^e6 reads\n    if ( line_count % buffer_size ==0)\n    {\n      it=over_rep_map.begin();\n      while(it != over_rep_map.end())\n      {\n        if (it->second <= min_size)\n        {\n          std::map<std::string, int>::iterator erase_it = it;\n          it++;\n          over_rep_map.erase(erase_it);\n        }\n        else\n        {\n          ++it;\n        }\n\n      }\n    }\n   line_count++;\n  }\n  //Cleanup\n  in.close();\n\n\n  /*TODO\n\n  over_rep_file.close();\n  */\n\n  return over_rep_map ;\n}\n\n\n\n",
    "created" : 1522788840023.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "736704800",
    "id" : "C0AE1581",
    "lastKnownWriteTime" : 1521128547,
    "last_content_update" : 1521128547,
    "path" : "~/Documents/Rdata/qckitW/src/read_fastq.cpp",
    "project_path" : "src/read_fastq.cpp",
    "properties" : {
    },
    "relative_order" : 10,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "cpp"
}